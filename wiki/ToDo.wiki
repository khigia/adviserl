#summary List of TODO (not features)
 * Deployment / build
     * ? sinan build system ... create dependancy with a repository?
     * ? CEAN packaging
     * look at some windows/mac build system (see with sinan)
     * OTP release
 * Documentation
     * main doc not uptodate with current code (adv_source, adv_item, load/save...)
     * document scripts in bin folder
     * real documentation: install, user, and devel guides
     * examples / testing
         * API examples
         * example/API/plugin(?) to clean the ratings with a given timestamp too old (use example of rating data)
         * example of using MySQL and some reporting data (how to implement a realtime callback?)
 * API
     * Internal
         * adviserl:info() to get global info (system alive, number of items, sources, size of data...)
         * add possibility to update some ratings witout updating the items, and the items in one time afterward (see example load which call directly adv_ratings and adv_items)
     * External
         * need to support multiple predictors for the same set of data (multiple prediction callback module): this enable to have multiple prediction algorithms for the same set of data
         * add some options to bin/adv-recommendall-source [-n api_node] [--sorted] [-n 5] 12 => print 2 numbers (itemID and score) by line
         * python interface to talk with adviserl_api (http://www.lysator.liu.se/~tab/erlang/py_interface)
         * HTTP interface (yaws/inets or see http://wiki.trapexit.org/index.php/A_fast_web_server_demonstrating_some_undocumented_Erlang_features)
 * Implementation / performance / algorithm
     * all data are stored in memory: persistence backend is clearly needed.
         * ratings could use ets/dets (what about using qlc?); mnesia could allow a partition of data
         * adv_items could use ets or mnesia with copy ... this has to be delegated in the callback module because each module need its own data (not all have a matrix form)
     * what about distributed collaborative filtering?
     * algorithm parallelism:
         * if prediction is a matrix base operation ... can be distributed (at least by group of lines)
         * building the matrix (init) can also be parallel
     * adv_slone:predict_all read the whole matrix: should be able to read only lines for which source has there is at least one rating value! : recommend_n (for all rows, look at N columns), need a fast way to get few recommendations (for the N rows, score by columns), recommend_one ...
     * lot of missing unit-test, especially inadv_slone (should validate algorithm, and manipulation like update)
     * implementation of adviserl:update_rating is not optimal: it undo all itemss for one user, then redo with the new value; it could only change what is relative to the updated item.
